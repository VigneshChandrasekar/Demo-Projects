<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Rebus</name>
    </assembly>
    <members>
        <member name="T:Rebus.Activation.BuiltinHandlerActivator">
            <summary>
            Built-in handler activator that can be used when dependency injection is not required, or when inline
            lambda-based handlers are wanted
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Returns all relevant handler instances for the given message by looking up compatible registered functions and instance factory methods.
            </summary>
        </member>
        <member name="P:Rebus.Activation.BuiltinHandlerActivator.Bus">
            <summary>
            Gets the bus instance that this activator was configured with
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.SetBus(Rebus.Bus.IBus)">
            <summary>
            Stores the bus instance
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{Rebus.Bus.IBus,Rebus.Pipeline.IMessageContext,``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/> with the <see cref="T:Rebus.Bus.IBus"/> and the current <see cref="T:Rebus.Pipeline.IMessageContext"/> available
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{Rebus.Bus.IBus,``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/> with the <see cref="T:Rebus.Bus.IBus"/> available
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{Rebus.Pipeline.IMessageContext,``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{Rebus.Bus.IBus,Rebus.Pipeline.IMessageContext,``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Dispose">
            <summary>
            Disposes the contained bus instance
            </summary>
        </member>
        <member name="T:Rebus.Activation.IContainerAdapter">
            <summary>
            Extends <see cref="T:Rebus.Activation.IHandlerActivator"/> with the expectation that it is backed by some kind of IoC container that can hold
            a bus instance (which it naturally should be able to inject into handlers when they're activated)
            </summary>
        </member>
        <member name="M:Rebus.Activation.IContainerAdapter.SetBus(Rebus.Bus.IBus)">
            <summary>
            Sets the bus instance that this <see cref="T:Rebus.Activation.IContainerAdapter"/> should be able to inject when resolving handler instances
            </summary>
        </member>
        <member name="T:Rebus.Activation.IHandlerActivator">
            <summary>
            Responsible for creating handlers for a given message type
            </summary>
        </member>
        <member name="M:Rebus.Activation.IHandlerActivator.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Must return all relevant handler instances for the given message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.AuditHeaders">
            <summary>
            Headers relevant when using message auditing
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.AuditTime">
            <summary>
            Header with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the message copy was forwarded to the audit queue.
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.HandleTime">
            <summary>
            Header with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the audited message was received.
            Only present on copies of handled messages (i.e. not on messages with <see cref="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe"/>
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.HandleQueue">
            <summary>
            Header with the queue name from which the message was received. 
            Only present on copies of handled messages (i.e. not on messages with <see cref="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe"/>
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.MachineName">
            <summary>
            Name of the machine that processed/published the message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.IncomingAuditingStep">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IIncomingStep"/> and <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that handles message auditing
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.IncomingAuditingStep.#ctor(Rebus.Auditing.Messages.AuditingHelper,Rebus.Transport.ITransport)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.MessageAuditingConfigurationExtensions">
            <summary>
            Configuration extensions for the auditing configuration
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.MessageAuditingConfigurationExtensions.EnableMessageAuditing(Rebus.Config.OptionsConfigurer,System.String)">
            <summary>
            Enables message auditing whereby Rebus will forward to the audit queue a copy of each properly handled message and
            each published message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.OutgoingAuditingStep">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IIncomingStep"/> and <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that handles message auditing
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.OutgoingAuditingStep.#ctor(Rebus.Auditing.Messages.AuditingHelper,Rebus.Transport.ITransport)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.ISagaSnapshotStorage">
            <summary>
            Saga snapshot storage that archives a snapshot of the given saga data
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.ISagaSnapshotStorage.Save(Rebus.Sagas.ISagaData,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Archives the given saga data under its current ID and revision
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions">
            <summary>
            Configuration extensions for the auditing configuration
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions.EnableSagaAuditing(Rebus.Config.OptionsConfigurer)">
            <summary>
            Enables saga auditing which will cause Rebus to save a snapshot of each saga state to the configured snapshot storage.
            Please remember to select a saga snapshot storage by calling an extension on the returned <see cref="T:Rebus.Config.StandardConfigurer`1"/>, e.g. like so:
            <code>
            Configure.With(..)
                .(...)
                .Options(o => o.EnableSagaAuditing().StoreInSqlServer(....))
                .Start();
            </code>
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions.OutputToLog(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage})">
            <summary>
            Configures Rebus to output saga snapshots to the log. Each saga data mutation will be logged as a serialized JSON object without type information
            with INFO level to the class-logger of <see cref="T:Rebus.Auditing.Sagas.LoggerSagaSnapperShotter"/>.
            This is probably mostly useful in debugging scenarios, or as a simple auditing mechanism in cases where sagas don't expect a lot of traffic.
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys">
            <summary>
            Contains keys of metadata elements that can be found alongside saga data snapshots when saga auditing has been enabled
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.HandleQueue">
            <summary>
            Key of the input queue address of the endpoint that handled the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.SagaDataType">
            <summary>
            Key of the type of the saga data
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.SagaHandlerType">
            <summary>
            Key of the type of the saga handler that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MessageType">
            <summary>
            Key of the type of the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MessageId">
            <summary>
            Key of the ID of the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MachineName">
            <summary>
            Key of the machine name on which the saga data was brought to the current state
            </summary>
        </member>
        <member name="T:Rebus.Backoff.BackoffConfigurationExtensions">
            <summary>
            Configuration extensions for customizing the backoff behavior
            </summary>
        </member>
        <member name="M:Rebus.Backoff.BackoffConfigurationExtensions.SetBackoffTimes(Rebus.Config.OptionsConfigurer,System.TimeSpan[])">
            <summary>
            Configures the timespans to wait when backing off polling the transport during idle times. <paramref name="backoffTimes"/>
            must be a sequence of timespans, which indicates the time to wait for each second elapsed being idle. When the idle time
            exceeds the number of timespans, the last timespan will be used.
            </summary>
        </member>
        <member name="M:Rebus.Backoff.BackoffConfigurationExtensions.SetBackoffTimes(Rebus.Config.OptionsConfigurer,System.Collections.Generic.IEnumerable{System.TimeSpan})">
            <summary>
            Configures the timespans to wait when backing off polling the transport during idle times. <paramref name="backoffTimes"/>
            must be a sequence of timespans, which indicates the time to wait for each second elapsed being idle. When the idle time
            exceeds the number of timespans, the last timespan will be used.
            </summary>
        </member>
        <member name="T:Rebus.Bus.RebusBus">
            <summary>
            The implementations of the advanced APIs are private classes inside <see cref="T:Rebus.Bus.RebusBus"/> so that they can access private functions and stuff
            </summary>
            <summary>
            This is the main bus thing which you'll most likely hold on to
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.#ctor(Rebus.Workers.IWorkerFactory,Rebus.Routing.IRouter,Rebus.Transport.ITransport,Rebus.Pipeline.IPipelineInvoker,Rebus.Subscriptions.ISubscriptionStorage,Rebus.Config.Options,Rebus.Logging.IRebusLoggerFactory,Rebus.Bus.BusLifetimeEvents,Rebus.DataBus.IDataBus,Rebus.Topic.ITopicNameConvention)">
            <summary>
            Constructs the bus.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Start(System.Int32)">
            <summary>
            Starts the bus by adding the specified number of workers
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to this instance's own input queue, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to the address mapped as the owner of the message type, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.DeferLocal(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the bus instance's own input address will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the endpoint mapping corresponding to the sent message will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Replies back to the endpoint specified as return address on the message currently being handled. Throws an <see cref="T:System.InvalidOperationException"/> if
            called outside of a proper message context.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Subscribe(System.Type)">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <paramref name="eventType"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Unsubscribe(System.Type)">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <paramref name="eventType"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="P:Rebus.Bus.RebusBus.Advanced">
            <summary>
            Gets the API for advanced features of the bus
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerPublish(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the specified event message on the specified topic, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerSubscribe(System.String)">
            <summary>
            Subscribes to the specified topic. If the current subscription storage is centralized, the subscription will be established right away. Otherwise, a <see cref="T:Rebus.Messages.Control.SubscribeRequest"/>
            will be sent to the address mapped as the owner (i.e. the publisher) of the given topic.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerUnsubscribe(System.String)">
            <summary>
            Unsubscribes from the specified topic. If the current subscription storage is centralized, the subscription will be removed right away. Otherwise, an <see cref="T:Rebus.Messages.Control.UnsubscribeRequest"/>
            will be sent to the address mapped as the owner (i.e. the publisher) of the given topic.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Dispose">
            <summary>
            Stops all workers, allowing them to finish handling the current message (for up to 1 minute) before exiting
            </summary>
        </member>
        <member name="E:Rebus.Bus.RebusBus.Disposed">
            <summary>
            Event that is raised when the bus is disposed
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.SetNumberOfWorkers(System.Int32)">
            <summary>
            Sets the number of workers by adding/removing one worker at a time until
            the desired number is reached
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.ToString">
            <summary>
            Gets a label for this bus instance - e.g. "RebusBus 2" if this is the 2nd instance created, ever, in the current process
            (or the name used when configuring it, if the name has been customized)
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.AsyncHelpers.RunSync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes a task synchronously on the calling thread by installing a temporary synchronization context that queues continuations
             </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.AsyncHelpers.CustomSynchronizationContext">
            <summary>
            Synchronization context that can be "pumped" in order to have it execute continuations posted back to it
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.AsyncHelpers.CustomSynchronizationContext.Run">
            <summary>
            Enqueues the function to be executed and executes all resulting continuations until it is completely done
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IAdvancedApi">
            <summary>
            API for the advanced features of the bus
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Workers">
            <summary>
            Gets an API to query/control various aspects around Rebus' workers
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Topics">
            <summary>
            Gets an API to do pub/sub on raw string-based topics
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Routing">
            <summary>
            Gets an API to explicitly route messages
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.TransportMessage">
            <summary>
            Gets an API to perform operations with the transport message currently being handled
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.DataBus">
            <summary>
            Gets the API for the data bus
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.SyncBus">
            <summary>
            Exposes a synchronous version of <see cref="T:Rebus.Bus.IBus"/> that essentially mimics all APIs only providing them in a synchronous version
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IRoutingApi">
            <summary>
            Provides a raw API for explicitly routing messages to other endpoints
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IRoutingApi.Send(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Explicitly routes the <paramref name="explicitlyRoutedMessage"/> to the destination specified by <paramref name="destinationAddress"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IRoutingApi.SendRoutingSlip(Rebus.Routing.Itinerary,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the message as a routing slip that will visit the destinations specified by the given <see cref="T:Rebus.Routing.Itinerary"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IRoutingApi.Defer(System.String,System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Explicitly routes the <paramref name="explicitlyRoutedMessage"/> to the destination specified by <paramref name="destinationAddress"/>,
            delaying delivery approximately by the time specified by <paramref name="delay"/>.
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ISyncBus">
            <summary>
            Synchronous API for all of the async-native operations of the Rebus <see cref="T:Rebus.Bus.IBus"/>. May be used in applications 
            that need to perform bus operations deep within a call hierarchy, or that simply do not contain an appropriate place
            to await something. Safe to use in applications that insist on running continuations on the initiating thread, like 
            e.g. ASP.NET and WPF.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified message to our own input queue address
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified message to a destination that is determined by calling <see cref="M:Rebus.Routing.IRouter.GetDestinationAddress(Rebus.Messages.Message)"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified reply message to a destination that is determined by looking up the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header of the message currently being handled.
            This method can only be called from within a message handler.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the endpoint mapping corresponding to the sent message will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.DeferLocal(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the bus instance's own input address will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Subscribe(System.Type)">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <paramref name="eventType"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Unsubscribe(System.Type)">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <paramref name="eventType"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ITopicsApi">
            <summary>
            Provides the raw topic-based pub/sub API which is used underneath the type-based pub/sub api provided by <see cref="T:Rebus.Bus.IBus"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Publish(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the specified message to the specified topic. Default behavior is to look up the addresses of those who subscribed to the given topic
            by calling <see cref="M:Rebus.Subscriptions.ISubscriptionStorage.GetSubscriberAddresses(System.String)"/> but the transport may override this behavior if it has special capabilities.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Subscribe(System.String)">
            <summary>
            Subscribes the current endpoint to the given topic. If the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> is centralized (determined by checking <see cref="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized"/>),
            the subscription is registered immediately. If not, the owner of the given topic is checked (by calling <see cref="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)"/>), and a
            <see cref="T:Rebus.Messages.Control.SubscribeRequest"/> is sent to the owning endpoint).
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Unsubscribe(System.String)">
            <summary>
            Unsubscribes the current endpoint from the given topic. If the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> is centralized (determined by checking <see cref="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized"/>),
            the subscription is removed immediately. If not, the owner of the given topic is checked (by calling <see cref="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)"/>), and an
            <see cref="T:Rebus.Messages.Control.UnsubscribeRequest"/> is sent to the owning endpoint).
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ITransportMessageApi">
            <summary>
            Contains operations that can be performed on the transport message currently being handled
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITransportMessageApi.Forward(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Forwards the transport message currently being handled to the specified queue, optionally supplying some extra headers
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITransportMessageApi.Defer(System.TimeSpan,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers the transport message currently being handled some time into the future, optionally specifying some additional headers
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IWorkersApi">
            <summary>
            Defines an API for working with workers
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IWorkersApi.Count">
            <summary>
            Gets how many workers are currently running
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IWorkersApi.SetNumberOfWorkers(System.Int32)">
            <summary>
            Sets the number of workers, blocking until the desired number has been reached
            </summary>
        </member>
        <member name="T:Rebus.Bus.BusLifetimeEvents">
            <summary>
            Has events that can be subscribed to if one wants to be notified when certain things happen
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusStarting">
            <summary>
            Event that is raised when the bus is starting BEFORE the bus adds any workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusStarted">
            <summary>
            Event that is raised when the bus is starting AFTER the bus hass added its workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusDisposing">
            <summary>
            Event that is raised when the bus is disposed BEFORE the bus raises its own <see cref="E:Rebus.Bus.RebusBus.Disposed"/> event
            BEFORE the bus stops its workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.WorkersStopped">
            <summary>
            Event that is raised when the bus is disposed BEFORE the bus raises its own <see cref="E:Rebus.Bus.RebusBus.Disposed"/> event, AFTER the bus has stopped all workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusDisposed">
            <summary>
            Event that is raised when the bus is disposed AFTER the bus raises its own <see cref="E:Rebus.Bus.RebusBus.Disposed"/> event
            </summary>
        </member>
        <member name="T:Rebus.Bus.IBus">
            <summary>
            This is the main bus API
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to this instance's own input queue, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to the address mapped as the owner of the message type, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.DeferLocal(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers the message delivery into the future, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the bus instance's own input queue address will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers the message delivery into the future, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the endpoint mapping corresponding to the sent message will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Replies back to the endpoint specified as return address on the message currently being handled. Throws an <see cref="T:System.InvalidOperationException"/> if called outside of a proper message context.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Subscribe(System.Type)">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <paramref name="eventType"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Unsubscribe(System.Type)">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <paramref name="eventType"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="P:Rebus.Bus.IBus.Advanced">
            <summary>
            Gets the API for advanced features of the bus
            </summary>
        </member>
        <member name="T:Rebus.Bus.IInitializable">
            <summary>
            Anything that is resolved with the injectionist can be marked as initializable by implementing this interface, which
            will then have its <see cref="M:Rebus.Bus.IInitializable.Initialize"/> method called before the bus is started
            </summary>
        </member>
        <member name="M:Rebus.Bus.IInitializable.Initialize">
            <summary>
            Initializes the instance
            </summary>
        </member>
        <member name="T:Rebus.Bus.MessageExtensions">
            <summary>
            Small helpers that make it easier to work with the <see cref="T:Rebus.Messages.Message"/> class
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.HasReturnAddress(Rebus.Messages.Message)">
            <summary>
            Gets whether the message's <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header is set to something
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetReturnAddressFromTransport(Rebus.Messages.Message,Rebus.Transport.ITransport)">
            <summary>
            Uses the transport's input queue address as the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> on the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetDeferHeaders(Rebus.Messages.Message,System.DateTimeOffset,System.String)">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header to the specified time
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetDeferHeaders(Rebus.Messages.TransportMessage,System.DateTimeOffset,System.String)">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header to the specified time
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageType(Rebus.Messages.Message)">
            <summary>
            Gets the message type from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageType(Rebus.Messages.TransportMessage)">
            <summary>
            Gets the message type from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageId(Rebus.Messages.Message)">
            <summary>
            Gets the message ID from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageId(Rebus.Messages.TransportMessage)">
            <summary>
            Gets the message ID from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageLabel(Rebus.Messages.Message)">
            <summary>
            Gets a nice label for the message, consisting of message type and ID if possible
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageLabel(Rebus.Messages.TransportMessage)">
            <summary>
            Gets a nice label for the message, consisting of message type and ID if possible
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.Clone(Rebus.Messages.TransportMessage)">
            <summary>
            Returns a cloned instance of the transport message
            </summary>
        </member>
        <member name="T:Rebus.Compression.DataCompressionMode">
            <summary>
            Enumerates strategies for when the data bus storage decorator GZIps the data
            </summary>
        </member>
        <member name="F:Rebus.Compression.DataCompressionMode.Always">
            <summary>
            Always compresses data. Please note that this requires that data can be kept in memory as this
            is required by the streaming APIs used when compressing data
            </summary>
        </member>
        <member name="F:Rebus.Compression.DataCompressionMode.Explicit">
            <summary>
            Compresses data when the <see cref="F:Rebus.DataBus.MetadataKeys.ContentEncoding"/> key is detected among the metadata
            of the save data and the value is "gzip"
            </summary>
        </member>
        <member name="T:Rebus.Compression.ZipConfigurationExtensions">
            <summary>
            Configuration extensions for enabling compression
            </summary>
        </member>
        <member name="F:Rebus.Compression.ZipConfigurationExtensions.DefaultBodyThresholdBytes">
            <summary>
            Default threshold for the body size for compression to kick in
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZipConfigurationExtensions.EnableCompression(Rebus.Config.OptionsConfigurer,System.Int32)">
            <summary>
            Enables compression of outgoing messages if the size exceeds the specified number of bytes
            (defaults to <see cref="F:Rebus.Compression.ZipConfigurationExtensions.DefaultBodyThresholdBytes"/>)
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZipConfigurationExtensions.UseCompression(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},Rebus.Compression.DataCompressionMode)">
            <summary>
            Enables GZIP of the saved data bus data. Set <paramref name="dataCompressionMode"/> to control when data is gzipped - if <see cref="F:Rebus.Compression.DataCompressionMode.Always"/>
            is selected the data will always be GZIPped, whereas selecting <see cref="F:Rebus.Compression.DataCompressionMode.Explicit"/> makes the data be GZIPped
            only when <see cref="F:Rebus.DataBus.MetadataKeys.ContentEncoding"/> = "gzip" is detected among the metadata for the stored data.
            Please note that GZIPping the data requires that it can be fully contained in memory because the underlying streaming APIs do not support lazy-reading a
            GZIP stream.
            </summary>
        </member>
        <member name="T:Rebus.Compression.Zipper">
            <summary>
            Zipper that holds the zipping logic
            </summary>
        </member>
        <member name="M:Rebus.Compression.Zipper.Zip(System.Byte[])">
            <summary>
            Zips the byte array
            </summary>
        </member>
        <member name="M:Rebus.Compression.Zipper.Unzip(System.Byte[])">
            <summary>
            Unzips the byte array
            </summary>
        </member>
        <member name="T:Rebus.Compression.ZippingDataBusStorageDecorator">
            <summary>
            Decorator for <see cref="T:Rebus.DataBus.IDataBusStorage"/> that GZIP-compresses data when it is streamed in/out
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.#ctor(Rebus.DataBus.IDataBusStorage,Rebus.Compression.DataCompressionMode)">
            <summary>
            Creates the decorator, wrapping the given <paramref name="innerDataBusStorage"/>
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.Read(System.String)">
            <summary>
            Opens the data stored under the given ID for reading
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.ReadMetadata(System.String)">
            <summary>
            Loads the metadata stored with the given ID
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the data from the given source stream under the given ID
            </summary>
        </member>
        <member name="T:Rebus.Config.Configure">
            <summary>
            Configuration entry point - call the static <see cref="M:Rebus.Config.Configure.With(Rebus.Activation.IHandlerActivator)"/> method with the chosen implementation of <see cref="T:Rebus.Activation.IHandlerActivator"/> 
            (e.g. <see cref="T:Rebus.Activation.BuiltinHandlerActivator"/>, or one that is backed by your favorite IoC container) in order to start configuring a
            Rebus instance
            </summary>
        </member>
        <member name="M:Rebus.Config.Configure.With(Rebus.Activation.IHandlerActivator)">
            <summary>
            Call this method with the chosen implementation of <see cref="T:Rebus.Activation.IHandlerActivator"/> (e.g. <see cref="T:Rebus.Activation.BuiltinHandlerActivator"/>, or one 
            that is backed by your favorite IoC container) in order to start configuring a
            Rebus instance
            </summary>
        </member>
        <member name="T:Rebus.Config.OneWayClientBackdoor">
            <summary>
            Helper that gives a backdoor to the configuration <see cref="T:Rebus.Config.Options"/>, allowing for one-way client settings
            to be set.
            </summary>
        </member>
        <member name="M:Rebus.Config.OneWayClientBackdoor.ConfigureOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport})">
            <summary>
            Uses the given <see cref="T:Rebus.Config.StandardConfigurer`1"/> of <see cref="T:Rebus.Transport.ITransport"/> to set the number of workers
            to zero (effectively disabling message processing) and installs a decorator of <see cref="T:Rebus.Bus.IBus"/> that prevents
            further modification of the number of workers (thus preventing accidentally starting workers when there's no input queue).
            </summary>
        </member>
        <member name="T:Rebus.Config.Options">
            <summary>
            Contains additional options for configuring Rebus internals
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultNumberOfWorkers">
            <summary>
            This is the default number of workers that will be started, unless <see cref="P:Rebus.Config.Options.NumberOfWorkers"/> is set to something else
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultMaxParallelism">
            <summary>
            This is the default number of concurrent asynchrounous operations allowed, unless <see cref="P:Rebus.Config.Options.MaxParallelism"/> is set to something else
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultWorkerShutdownTimeout">
            <summary>
            This is the default timeout for workers to finish running active handlers, unless <see cref="P:Rebus.Config.Options.WorkerShutdownTimeout" /> is set to something else.
            </summary>
            <value>1 minute per default.</value>
        </member>
        <member name="F:Rebus.Config.Options.DefaultDueTimeoutsPollInterval">
            <summary>
            This is the default due timeouts poll interval which will be used unless overridde by <see cref="P:Rebus.Config.Options.DueTimeoutsPollInterval"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.Options.#ctor">
            <summary>
            Constructs the options with the default settings
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.NumberOfWorkers">
            <summary>
            Configures the number of workers. If thread-based workers are used, this is the number of threads that will be created.
            This number should be less than or equal to <see cref="P:Rebus.Config.Options.MaxParallelism"/>.
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.MaxParallelism">
            <summary>
            Configures the total degree of parallelism allowed. This will be the maximum number of parallel potentially asynchrounous operations that can be active,
            regardless of the number of workers
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.ExternalTimeoutManagerAddressOrNull">
            <summary>
            Gets/sets the address to use if an external timeout manager is to be used
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.DueTimeoutsPollInterval">
            <summary>
            Gets/sets the poll interval when checking for due timeouts
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.WorkerShutdownTimeout">
            <summary>
            Gets/sets the maximum timeout for workers to finish running active handlers after being signaled to stop.
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.OptionalBusName">
            <summary>
            Gets/sets the name of the bus. If this is left unset, bus instances will be named with numbers.
            </summary>
        </member>
        <member name="T:Rebus.Config.OptionsConfigurer">
            <summary>
            Allows for configuring additional options
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetNumberOfWorkers(System.Int32)">
            <summary>
            Configures the number of workers to start competing over the input queue
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetBusName(System.String)">
            <summary>
            Sets the bus name, which would otherwise default to "Rebus 1", "Rebus 2", etc. 
            depending on how many instances existed in the current process
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetMaxParallelism(System.Int32)">
            <summary>
            Configures the total degree of parallelism allowed. This will be the maximum number of parallel potentially asynchrounous operations that can be active,
            regardless of the number of workers
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetWorkerShutdownTimeout(System.TimeSpan)">
            <summary>
            Configures the maximum timeout for workers to finish running active handlers after being signaled to stop.
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetDueTimeoutsPollInteval(System.TimeSpan)">
            <summary>
            Configures the interval between polling the endpoint's configured <see cref="T:Rebus.Timeouts.ITimeoutManager"/> for due timeouts.
            Defaults to <see cref="F:Rebus.Config.Options.DefaultDueTimeoutsPollInterval"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.Register``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers the given factory function as a resolver of the given primary implementation of the <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.Has``1">
            <summary>
            Gets whether a primary implementation resolver has been registered for the <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.Decorate``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given decorator of the <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.LogPipeline(System.Boolean)">
            <summary>
            Outputs the layout of the send and receive pipelines to the log
            </summary>
        </member>
        <member name="T:Rebus.Config.RebusConfigurer">
            <summary>
            Basic skeleton of the fluent configuration builder. Contains a method for each aspect that can be configured
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Logging(System.Action{Rebus.Config.RebusLoggingConfigurer})">
            <summary>
            Configures how Rebus logs stuff that happens
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Transport(System.Action{Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport}})">
            <summary>
            Configures how Rebus sends/receives messages by allowing for choosing which implementation of <see cref="T:Rebus.Transport.ITransport"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Routing(System.Action{Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter}})">
            <summary>
            Configures how Rebus routes messages by allowing for choosing which implementation of <see cref="T:Rebus.Routing.IRouter"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Sagas(System.Action{Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage}})">
            <summary>
            Configures how Rebus persists saga data by allowing for choosing which implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Subscriptions(System.Action{Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage}})">
            <summary>
            Configures how Rebus persists subscriptions by allowing for choosing which implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Serialization(System.Action{Rebus.Config.StandardConfigurer{Rebus.Serialization.ISerializer}})">
            <summary>
            Configures how Rebus serializes messages by allowing for choosing which implementation of <see cref="T:Rebus.Serialization.ISerializer"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Timeouts(System.Action{Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager}})">
            <summary>
            Configures how Rebus defers messages to the future by allowing for choosing which implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Options(System.Action{Rebus.Config.OptionsConfigurer})">
            <summary>
            Configures additional options about how Rebus works
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Start">
            <summary>
            Finishes the setup of the bus, using default implementations for the options that have not explicitly been set.
            The only requirement, is that you must call <see cref="M:Rebus.Config.RebusConfigurer.Transport(System.Action{Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport}})"/> and select which transport to use - everything
            else can run with a default option. It should be noted though, that several of the defaults (e.g. in-mem persistence
            options for saga storage, subscriptions, and timeouts) are not meant for production use, and should probably be
            replaced by something that is actually persistent.
            </summary>
        </member>
        <member name="T:Rebus.Config.RebusLoggingConfigurer">
            <summary>
            Configurer that is used to configure logging. This configurer is cheating a little bit because it will actually modify a global logger which will
            be used throughout all Rebus instances. This mechanism might change in the future
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Console(Rebus.Logging.LogLevel)">
            <summary>
            Configures Rebus to log its stuff to stdout, possibly ignore logged lines under the specified <see cref="T:Rebus.Logging.LogLevel"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.ColoredConsole(Rebus.Logging.LogLevel)">
            <summary>
            Configures Rebus to log its stuff to with different colors depending on the log level, possibly ignore logged lines under the specified <see cref="T:Rebus.Logging.LogLevel"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Trace">
            <summary>
            Configures Rebus to log its stuff to <see cref="T:System.Diagnostics.Trace"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.None">
            <summary>
            Disables logging alltogether
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Use(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Configures this Rebus instance to use the specified logger factory
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Register``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Decorate``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="T:Rebus.Config.StandardConfigurer`1">
            <summary>
            Configurer that can have extension methods attached to it for helping with registering an implementation or a decorator
            for the <typeparamref name="TService"/> service.
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.GetConfigurerFrom(Rebus.Config.OptionsConfigurer)">
            <summary>
            Gets a standard configurer from the given options configurer. Can be used to provide
            extensions to <see cref="T:Rebus.Config.OptionsConfigurer"/> that return a standard configurer that can then
            be used to build further
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.Register(System.Func{Rebus.Injection.IResolutionContext,`0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.Decorate(System.Func{Rebus.Injection.IResolutionContext,`0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.OtherService``1">
            <summary>
            Gets a typed configurer for another service. Can be useful if e.g. a configuration extension for a <see cref="T:Rebus.Transport.ITransport"/>
            wants to replace the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> because it is capable of using the transport layer to do pub/sub
            </summary>
        </member>
        <member name="T:Rebus.DataBus.DataBusAttachment">
            <summary>
            Model that represents a data bus attachment. Only the <see cref="P:Rebus.DataBus.DataBusAttachment.Id"/> is significant, as all the
            other pieces of information are not required in order to retrieve the attachment from the database.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.#ctor(System.String)">
            <summary>
            Creates a data bus attachment with the given ID
            </summary>
        </member>
        <member name="P:Rebus.DataBus.DataBusAttachment.Id">
            <summary>
            Gets the ID of the attachment
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.OpenRead">
            <summary>
            Opens the attachment for reading, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.GetMetadata">
            <summary>
            Gets the metadata associated with the attachment, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.OpenRead(System.String)">
            <summary>
            Opens the attachment for reading, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.GetMetadata(System.String)">
            <summary>
            Gets the metadata associated with the attachment, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="T:Rebus.DataBus.DataBusOptionsExtensions">
            <summary>
            Configuration extensions for Rebus' data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusOptionsExtensions.EnableDataBus(Rebus.Config.OptionsConfigurer)">
            <summary>
            Enables the data bus. 
            Please remember to select a data bus storage by calling an extension on the returned <see cref="T:Rebus.Config.StandardConfigurer`1"/>, e.g. like so:
            <code>
            Configure.With(..)
                .(...)
                .Options(o => o.EnableDataBus().StoreInSqlServer(....))
                .Start();
            </code>
            </summary>
        </member>
        <member name="T:Rebus.DataBus.FileSystem.FileSystemDataBusExtensions">
            <summary>
            Provides extensions methods for configuring the file system storage for the data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusExtensions.StoreInFileSystem(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},System.String)">
            <summary>
            Configures the data bus to store data in the file system
            </summary>
        </member>
        <member name="T:Rebus.DataBus.FileSystem.FileSystemDataBusStorage">
            <summary>
            Implementation of <see cref="T:Rebus.DataBus.IDataBusStorage"/> that stores data in the file system. Could be a directory on a network share.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates the data storage
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.Initialize">
            <summary>
            Initializes the file system data storage by ensuring that the configured data directory path exists and that it is writable
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the data from the given strea under the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.Read(System.String)">
            <summary>
            Reads the data with the given ID and returns it as a stream
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.ReadMetadata(System.String)">
            <summary>
            Loads the metadata stored with the given ID
            </summary>
        </member>
        <member name="T:Rebus.DataBus.IDataBus">
            <summary>
            API for Rebus' data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBus.CreateAttachment(System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Creates an attachment from the given source stream, optionally providing some extra metadata to be stored along with the attachment
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBus.OpenRead(System.String)">
            <summary>
            Opens the attachment for reading, using the currently configured data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBus.GetMetadata(System.String)">
            <summary>
            Uses the currently configured data bus to retrieve the metadata for the attachment with the given ID
            </summary>
        </member>
        <member name="T:Rebus.DataBus.IDataBusStorage">
            <summary>
            Abstraction over the data bus storage
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBusStorage.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the data from the given source stream under the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBusStorage.Read(System.String)">
            <summary>
            Opens the data stored under the given ID for reading
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBusStorage.ReadMetadata(System.String)">
            <summary>
            Loads the metadata stored with the given ID
            </summary>
        </member>
        <member name="T:Rebus.DataBus.InMem.InMemDataBusExtensions">
            <summary>
            Configuration extensions for the in-mem data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataBusExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},Rebus.DataBus.InMem.InMemDataStore)">
            <summary>
            Configures the data bus to store data in memory. This is probably only useful for test scenarios, as the
            passed-in <paramref name="inMemDataStore"/> needs to be shared among endpoints on the data bus.
            </summary>
        </member>
        <member name="T:Rebus.DataBus.InMem.InMemDataStore">
            <summary>
            In-mem implementation of a data store that can be shared among buses that use the in-mem data bus.
            A shared instance of this class should be passed to all endpoints when calling <see cref="M:Rebus.DataBus.InMem.InMemDataBusExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},Rebus.DataBus.InMem.InMemDataStore)"/>
            </summary>
        </member>
        <member name="P:Rebus.DataBus.InMem.InMemDataStore.SizeBytes">
            <summary>
            Gets the total size in bytes 
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.Save(System.String,System.Byte[],System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the given bytes under the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.Load(System.String)">
            <summary>
            Loads the bytes with the given ID. Throws a <see cref="T:System.ArgumentException"/> if no
            such ID exists
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.AddMetadata(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Adds the metadata from the <paramref name="metadata"/> dictionary to the blob with the given <paramref name="id"/>
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.LoadMetadata(System.String)">
            <summary>
            Loads the metadata for the data with the given ID. Throws a <see cref="T:System.ArgumentException"/> if no
            such ID exists
            </summary>
        </member>
        <member name="T:Rebus.DataBus.MetadataKeys">
            <summary>
            Contains keys of standard metadata which is always available on data stored with the data bus
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.Length">
            <summary>
            Metadata key of the length in bytes of the stored data
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.SaveTime">
            <summary>
            Metadata key of the ISO8601-encoded time of when the data was stored
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.ReadTime">
            <summary>
            Metadata key of the ISO8601-encoding time of when the data was last read
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.ContentEncoding">
            <summary>
            Optional header that might contain an encoding of the contents, e.g."gzip" for gzipped data.
            </summary>
        </member>
        <member name="T:Rebus.Encryption.DecryptMessagesIncomingStep">
            <summary>
            Incoming message step that checks for the prensence of the <see cref="F:Rebus.Encryption.EncryptionHeaders.ContentEncryption"/> header, decrypting
            the message body if it is present.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.DecryptMessagesIncomingStep.#ctor(Rebus.Encryption.IEncryptor)">
            <summary>
            Constructs the step with the given encryptor
            </summary>
        </member>
        <member name="M:Rebus.Encryption.DecryptMessagesIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Descrypts the incoming <see cref="T:Rebus.Messages.TransportMessage"/> if it has the <see cref="F:Rebus.Encryption.EncryptionHeaders.ContentEncryption"/> header
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptedData">
            <summary>
            Represents a chunk of encrypted data along with the salt (a.k.a. "Initialization Vector"/"IV") that was used to encrypt it.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptedData.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Constructs an instance from the given bytes and iv.
            </summary>
        </member>
        <member name="P:Rebus.Encryption.EncryptedData.Iv">
            <summary>
            Gets the salt (a.k.a. "Initialization Vector"/"IV") from this encrypted data instance
            </summary>
        </member>
        <member name="P:Rebus.Encryption.EncryptedData.Bytes">
            <summary>
            Gets the raw data from this encrypted data instance
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptionConfigurationExtensions">
            <summary>
            Configuration extensions for enabling encrypted message bodies
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptionConfigurationExtensions.EnableEncryption(Rebus.Config.OptionsConfigurer,System.String)">
            <summary>
            Configures Rebus to encrypt outgoing messages and be able to decrypt incoming messages. 
            Uses the default "Rijndael" algorithm which is 256 bit AES encryption.
            Please note that it's only the message bodies that are encrypted, thus everything included in the message headers will be visible to eavesdroppers.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptionConfigurationExtensions.EnableCustomEncryption(Rebus.Config.OptionsConfigurer)">
            <summary>
            Configures Rebus to encrypt outgoing messages and be able to decrypt incoming messages using custom encryption provider.
            Please note that it's only the message bodies that are encrypted, thus everything included in the message headers will be visible to eavesdroppers.
            Custom encrypotion providers are configured by building on the returned configurer, e.g. like so:
            <code>
            Configure.With(...)
                .(...)
                .Options(o => {
                    o.EnableCustomEncryption()
                        .Use***();
                })
                .Start();
            </code>
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptionHeaders">
            <summary>
            Special headers that are used when the message contents are encrypted
            </summary>
        </member>
        <member name="F:Rebus.Encryption.EncryptionHeaders.ContentEncryption">
            <summary>
            Optional header element that specifies an encryption algorithm that the contents have been encrypted with
            </summary>
        </member>
        <member name="F:Rebus.Encryption.EncryptionHeaders.ContentInitializationVector">
            <summary>
            When the contents have been encrypted, this header has the IV
            </summary>
        </member>
        <member name="F:Rebus.Encryption.EncryptionHeaders.DisableEncryptionHeader">
            <summary>
            Special header that can be added to a message in order to disable encryption for that particular message
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptMessagesOutgoingStep">
            <summary>
            Outgoing pipeline step that encrypts the contents of the outgoing message
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptMessagesOutgoingStep.#ctor(Rebus.Encryption.IEncryptor)">
            <summary>
            Constructs the step with the given encryptor
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptMessagesOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Encrypts the outgoing <see cref="T:Rebus.Messages.TransportMessage"/> and adds appropriate headers
            </summary>
        </member>
        <member name="T:Rebus.Encryption.IEncryptor">
            <summary>
            Interface to provide encryption/decryption custom implementation
            </summary>
        </member>
        <member name="P:Rebus.Encryption.IEncryptor.ContentEncryptionValue">
            <summary>
            Header name that will be added to an encrypted message
            </summary>
        </member>
        <member name="M:Rebus.Encryption.IEncryptor.Decrypt(Rebus.Encryption.EncryptedData)">
            <summary>
            Decrypts the encrypted data
            </summary>
        </member>
        <member name="M:Rebus.Encryption.IEncryptor.Encrypt(System.Byte[])">
            <summary>
            Encrypts the given bytes and returns the encrypted data alond with the salt in the returned <see cref="T:Rebus.Encryption.EncryptedData"/>
            </summary>
        </member>
        <member name="T:Rebus.Encryption.RijndaelEncryptor">
            <summary>
            Helps with encrypting/decripting byte arrays, using the <see cref="T:System.Security.Cryptography.RijndaelManaged"/> algorithm
            </summary>
        </member>
        <member name="P:Rebus.Encryption.RijndaelEncryptor.ContentEncryptionValue">
            <summary>
            Returns "rijndael" string
            </summary>
        </member>
        <member name="M:Rebus.Encryption.RijndaelEncryptor.#ctor(System.String)">
            <summary>
            Creates the encrptor with the specified key - the key must be a valid, base64-encoded key
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Rebus.Encryption.RijndaelEncryptor.Encrypt(System.Byte[])">
            <summary>
            Encrypts the given array of bytes, using the configured key. Returns an <see cref="T:Rebus.Encryption.EncryptedData"/> containing the encrypted
            bytes and the generated salt.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.RijndaelEncryptor.Decrypt(Rebus.Encryption.EncryptedData)">
            <summary>
            Decrypts the given <see cref="T:Rebus.Encryption.EncryptedData"/> using the configured key.
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.ConcurrencyException">
            <summary>
            Special exception that signals that some kind of optimistic lock has been violated, and work must most likely be aborted &amp; retried
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.ConcurrencyException.#ctor(System.String)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.ConcurrencyException.#ctor(System.Exception,System.String)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.ConcurrencyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.FailFastException">
            <summary>
            Fail-fast exception bypasses the retry logic and goes to the error queue directly
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.FailFastException.#ctor(System.String)">
            <summary>
            Constructs the exception with the given message
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.FailFastException.#ctor(System.Exception,System.String)">
            <summary>
            Constructs the exception with the given message and inner exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.FailFastException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Happy cross-domain serialization!
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.IFailFastException">
            <summary>
            Marker interface for exceptions for which Rebus should not bother to retry delivery
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.Ignorant">
            <summary>
            Helps keeping track of errors that we want to ignore for a while before acknowledging them
            </summary>
        </member>
        <member name="P:Rebus.Exceptions.Ignorant.SilencePeriods">
            <summary>
            Gets/sets the silence periods, i.e. the length of the intervals in which the ignorant will be silent
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.Ignorant.#ctor(System.Func{System.Exception,System.String})">
            <summary>
            Constructs the ignorant with the given mapping from an exception instance to the equality key that will be used to compare with previous exceptions.
            If no equality key mapper is given, it will default to using <see cref="P:System.Type.FullName"/> of the exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.Ignorant.IsToBeIgnored(System.Exception)">
            <summary>
            Checks whether the given exception is to be ignored
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.Ignorant.Reset">
            <summary>
            Resets the silence period tracker - should be called after each success
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.MessageCouldNotBeDispatchedToAnyHandlersException">
            <summary>
            Fail-fast exception bypasses the retry logic and goes to the error queue directly
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.MessageCouldNotBeDispatchedToAnyHandlersException.#ctor(System.String)">
            <summary>
            Constructs the exception with the given message
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.MessageCouldNotBeDispatchedToAnyHandlersException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Happy cross-domain serialization!
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.RebusApplicationException">
            <summary>
            Generic application exception to use when something bad happens that is pretty unexpected and should be taken seriously
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusApplicationException.#ctor(System.String)">
            <summary>
            Constructs the exception with the given message
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusApplicationException.#ctor(System.Exception,System.String)">
            <summary>
            Constructs the exception with the given message and inner exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusApplicationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Happy cross-domain serialization!
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.RebusConfigurationException">
            <summary>
            Generic configuration exception to use instead of ConfigurationErrorsException from System.Configuration
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusConfigurationException.#ctor(System.String)">
            <summary>
            Constructs the exception with the given message
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusConfigurationException.#ctor(System.Exception,System.String)">
            <summary>
            Constructs the exception with the given message and inner exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusConfigurationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Happy cross-domain serialization!
            </summary>
        </member>
        <member name="T:Rebus.Extensions.DateTimeExtensions">
            <summary>
            Defines a few nice extensions for making working with <see cref="T:System.DateTimeOffset"/> more nice
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DateTimeExtensions.ElapsedUntilNow(System.DateTimeOffset)">
            <summary>
            Gets the time from this instant until now (as returned by <see cref="P:Rebus.Time.RebusTime.Now"/>)
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DateTimeExtensions.ToIso8601DateTimeOffset(System.DateTimeOffset)">
            <summary>
            Serializes this instant with the "O" format, i.e. ISO8601-compliant
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DateTimeExtensions.ToDateTimeOffset(System.String)">
            <summary>
            Parses an ISO8601-compliant string into a proper <see cref="T:System.DateTimeOffset"/>
            </summary>
        </member>
        <member name="T:Rebus.Extensions.DictionaryExtensions">
            <summary>
            Provides some nifty extensions to <see cref="T:System.Collections.Generic.Dictionary`2"/> and <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.MergedWith``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Returns a new dictionary that contains all key-value pairs from both dictionaries. If the same key is present the value from <paramref name="otherDictionary"/> takes precedence
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.Clone(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Returns a new dictionary with the same key-value pairs as the target
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetValue(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Gets the value with the given key from the dictionary, throwing a MUCH nicer <see cref="T:System.Collections.Generic.KeyNotFoundException"/>
            if the key does not exist
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetValueOrNull(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Gets the value with the given key from the dictionary, returning null if the key does not exist
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.Dictionary{System.String,``1},System.String,System.Func{``0})">
            <summary>
            Provides a function similar to <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})"/>, only
            on <see cref="T:System.Collections.Generic.Dictionary`2"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrAddAsync``2(System.Collections.Generic.Dictionary{System.String,``1},System.String,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Provides a function similar to <see cref="M:Rebus.Extensions.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.Dictionary{System.String,``1},System.String,System.Func{``0})"/>, only where the factory function can be async
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.ToConcurrentDictionary``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>
            Maps the given sequence of items to key-value pairs, returning them in a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrThrow``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, throwing a nice exception if either the key
            does not exist, or the found value cannot be cast to the given type
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrNull``1(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, returning null if the key does not exist.
            If the key exists, but the object could not be cast to the given type, a nice exception is throws
            </summary>
        </member>
        <member name="T:Rebus.Extensions.EnumerableExtensions">
            <summary>
            Nifty extensions for <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.EnumerableExtensions.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the items of the sequence in a new <see cref="T:System.Collections.Generic.HashSet`1"/> 
            </summary>
        </member>
        <member name="M:Rebus.Extensions.EnumerableExtensions.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns the items of the sequence in a new <see cref="T:System.Collections.Generic.HashSet`1"/>, checking equality with the given <paramref name="equalityComparer"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Iterates the sequence, calling the given <paramref name="itemAction"/> for each item
            </summary>
        </member>
        <member name="T:Rebus.Extensions.TypeExtensions">
            <summary>
            Provides extensions of <see cref="T:System.Type"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.TypeExtensions.GetBaseTypes(System.Type)">
            <summary>
            Gets the type's base types (i.e. the <see cref="T:System.Type"/> for each implemented interface and for each class inherited from, all the way up to <see cref="T:System.Object"/>)
            </summary>
        </member>
        <member name="M:Rebus.Extensions.TypeExtensions.GetSimpleAssemblyQualifiedName(System.Type)">
            <summary>
            Gets the assembly-qualified name of the type, without any version info etc.
            E.g. "System.String, mscorlib"
            </summary>
        </member>
        <member name="T:Rebus.Handlers.IHandleMessages">
            <summary>
            Base message handler interface. Don't implement this one directly, it would give you nothing
            </summary>
        </member>
        <member name="T:Rebus.Handlers.IHandleMessages`1">
            <summary>
            Message handler interface. Implement this in order to get to handle messages of a specific type
            </summary>
        </member>
        <member name="M:Rebus.Handlers.IHandleMessages`1.Handle(`0)">
            <summary>
            This method will be invoked with a message of type <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Handlers.InternalHandlersContributor">
            <summary>
            Decoration of <see cref="T:Rebus.Activation.IHandlerActivator"/> that adds a few special handlers when an incoming message can be recognized
            as a special Rebus message
            </summary>
        </member>
        <member name="M:Rebus.Handlers.InternalHandlersContributor.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Gets Rebus' own internal handlers (if any) for the given message type
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration">
            <summary>
            Configurer returned from <see cref="M:Rebus.Handlers.Reordering.ReorderingConfiguration.First``1"/> that allows for specifying additional handler types
            whose order to fix
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration.Then``1">
            <summary>
            Specifies the handler that will be put next in the pipeline if it is present - call <see cref="M:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration.Then``1"/>
            again to specify the next handler
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions">
            <summary>
            Configuration extensions for setting up an order of handlers that must be respected when
            two or more of the handlers are present in the same handler pipeline
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions.SpecifyOrderOfHandlers(Rebus.Config.OptionsConfigurer)">
            <summary>
            Initiates the configuration of the handler ordering - call <see cref="M:Rebus.Handlers.Reordering.ReorderingConfiguration.First``1"/> in
            order to specify the handler that will be put first in the pipeline if it is present
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.HandlerReorderingStep">
            <summary>
            Incoming message step that can reorder handlers
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.HandlerReorderingStep.#ctor(Rebus.Handlers.Reordering.ReorderingConfiguration)">
            <summary>
            Constructs the step with the given configuration
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.HandlerReorderingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Reorders the handler invokers if necessary
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.ReorderingConfiguration">
            <summary>
            Configurer returned from <see cref="M:Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions.SpecifyOrderOfHandlers(Rebus.Config.OptionsConfigurer)"/> that can be used as a
            fluent syntax to specify the desired order of the handlers
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.ReorderingConfiguration.First``1">
            <summary>
            Specifies the handler that will be put first in the pipeline if it is present - call <see cref="M:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration.Then``1"/>
            any number of times to specify the next handler
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.ReorderingConfiguration.GetIndex(System.Object)">
            <summary>
            Gets the sorting index for the given handler
            </summary>
        </member>
        <member name="T:Rebus.Injection.Injectionist">
            <summary>
            Dependency injectionist that can be used for configuring a system of injected service implementations, possibly with decorators,
            with caching of instances so that the same instance of each class is used throughout the tree. Should probably not be used for
            anything at runtime, is only meant to be used in configuration scenarios.
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Get``1">
            <summary>
            Starts a new resolution context, resolving an instance of the given <typeparamref name="TService"/>
            </summary>
        </member>
        <member name="E:Rebus.Injection.Injectionist.ResolveRequested">
            <summary>
            Events that is raised when the resolution of a top-level instance is requested
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Register``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers a factory method that can provide an instance of <typeparamref name="TService"/>. Optionally,
            the supplied <paramref name="description"/> will be used to report more comprehensible errors in case of
            conflicting registrations.
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Decorate``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers a decorator factory method that can provide an instance of <typeparamref name="TService"/> 
            (i.e. the resolver is expected to call <see cref="M:Rebus.Injection.IResolutionContext.Get``1"/> where TService
            is <typeparamref name="TService"/>. Optionally, the supplied <paramref name="description"/> will be used 
            to report more comprehensible errors in case of conflicting registrations.
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Has``1(System.Boolean)">
            <summary>
            Returns whether there exists a registration for the specified <typeparamref name="TService"/>.
            </summary>
        </member>
        <member name="T:Rebus.Injection.IResolutionContext">
            <summary>
            Represents the context of resolving one root service and can be used throughout the tree to fetch something to be injected
            </summary>
        </member>
        <member name="M:Rebus.Injection.IResolutionContext.Get``1">
            <summary>
            Gets an instance of the specified <typeparamref name="TService"/>.
            </summary>
        </member>
        <member name="P:Rebus.Injection.IResolutionContext.TrackedInstances">
            <summary>
            Gets all instances resolved within this resolution context at this time.
            </summary>
        </member>
        <member name="M:Rebus.Injection.IResolutionContext.Has``1(System.Boolean)">
            <summary>
            Gets whether there exists a primary registration for the <typeparamref name="TService"/> type
            </summary>
        </member>
        <member name="T:Rebus.Injection.ResolutionException">
            <summary>
            Exceptions that is thrown when something goes wrong while working with the injectionist
            </summary>
        </member>
        <member name="M:Rebus.Injection.ResolutionException.#ctor(System.String)">
            <summary>
            