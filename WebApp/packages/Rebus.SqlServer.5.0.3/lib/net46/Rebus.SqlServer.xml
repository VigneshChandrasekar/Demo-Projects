<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Rebus.SqlServer</name>
    </assembly>
    <members>
        <member name="T:Rebus.Config.SqlServerDataBusConfigurationExtensions">
            <summary>
            Configuration extensions for SQL Server data bus
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerDataBusConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},System.String,System.String,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Configures the data bus to store data in a central SQL Server 
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerDataBusConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.String,System.Boolean,System.Int32)">
            <summary>
            Configures the data bus to store data in a central SQL Server 
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerSagaConfigurationExtensions">
            <summary>
            Configuration extensions for sagas
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store sagas, using the tables specified to store data and indexed properties respectively.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.String,System.String,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store sagas, using the tables specified to store data and indexed properties respectively.
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerSagaSnapshotsConfigurationExtensions">
            <summary>
            Configuration extensions for saga snapshots
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaSnapshotsConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage},System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to store saga snapshots in SQL Server
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaSnapshotsConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.String,System.Boolean)">
            <summary>
            Configures Rebus to store saga snapshots in SQL Server
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerSubscriptionsConfigurationExtensions">
            <summary>
            Configuration extensions for subscriptions
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSubscriptionsConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage},System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store subscriptions. Use <paramref name="isCentralized"/> = true to indicate whether it's OK to short-circuit
            subscribing and unsubscribing by manipulating the subscription directly from the subscriber or just let it default to false to preserve the
            default behavior.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSubscriptionsConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.String,System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store subscriptions. Use <paramref name="isCentralized"/> = true to indicate whether it's OK to short-circuit
            subscribing and unsubscribing by manipulating the subscription directly from the subscriber or just let it default to false to preserve the
            default behavior.
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerTimeoutsConfigurationExtensions">
            <summary>
            Configuration extensions for configuring SQL persistence for sagas, subscriptions, and timeouts.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTimeoutsConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager},System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store timeouts.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTimeoutsConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.String,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store timeouts.
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerTransportConfigurationExtensions">
            <summary>
            Configuration extensions for the SQL transport
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServerInLeaseModeAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Boolean,System.Nullable{System.TimeSpan},System.Func{System.String},System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server as its transport (in "one-way client mode", i.e. as a send-only endpoint). Unlike the <c>UseSqlServer</c> calls the leased version of the SQL 
            Server transport does not hold a transaction open for the entire duration of the message handling. Instead it marks a
            message as being "leased" for a period of time. If the lease has expired then a worker is permitted to acquire the that
            message again and try reprocessing
            </summary>
            <param name="configurer">Static to extend</param>
            <param name="connectionString">Connection string</param>
            <param name="leaseInterval">If <c>null</c> will default to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTime"/>. Specifies how long a worker will request to keep a message. Higher values require less database communication but increase latency of a message being processed if a worker dies</param>
            <param name="leaseTolerance">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTolerance"/>. Workers will wait for this amount of time to elapse, beyond the lease time, before they pick up an already leased message.</param>
            <param name="automaticallyRenewLeases">If <c>true</c> then workers will automatically renew the lease they have acquired whilst they're still processing the message. This will occur in accordance with <paramref name="leaseAutoRenewInterval"/></param>
            <param name="leaseAutoRenewInterval">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseAutomaticRenewal"/>. Specifies how frequently a lease will be renewed whilst the worker is processing a message. Lower values decrease the chance of other workers processing the same message but increase DB communication. A value 50% of <paramref name="leaseInterval"/> should be appropriate</param>
            <param name="leasedByFactory">If non-<c>null</c> a factory which returns a string identifying this worker when it leases a message. If <c>null></c> the current machine name is used</param>
            <param name="enlistInAmbientTransaction">If <c>true</c> the connection will be enlisted in the ambient transaction if it exists, else it will create an SqlTransaction and enlist in it</param>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServerInLeaseModeAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Boolean,System.Nullable{System.TimeSpan},System.Func{System.String})">
            <summary>
            Configures Rebus to use SQL Server as its transport (in "one-way client mode", i.e. as a send-only endpoint). The message table will automatically be created if it does not exist.
            </summary>
            <param name="configurer">Static to extend</param>
            <param name="connectionFactory">Factory to provide a new connection</param>
            <param name="leaseInterval">If <c>null</c> will default to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTime"/>. Specifies how long a worker will request to keep a message. Higher values require less database communication but increase latency of a message being processed if a worker dies</param>
            <param name="leaseTolerance">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTolerance"/>. Workers will wait for this amount of time to elapse, beyond the lease time, before they pick up an already leased message.</param>
            <param name="automaticallyRenewLeases">If <c>true</c> then workers will automatically renew the lease they have acquired whilst they're still processing the message. This will occur in accordance with <paramref name="leaseAutoRenewInterval"/></param>
            <param name="leaseAutoRenewInterval">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseAutomaticRenewal"/>. Specifies how frequently a lease will be renewed whilst the worker is processing a message. Lower values decrease the chance of other workers processing the same message but increase DB communication. A value 50% of <paramref name="leaseInterval"/> should be appropriate</param>
            <param name="leasedByFactory">If non-<c>null</c> a factory which returns a string identifying this worker when it leases a message. If <c>null></c> the current machine name is used</param>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServerInLeaseMode(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String,System.String,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Boolean,System.Nullable{System.TimeSpan},System.Func{System.String},System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server as its transport. Unlike the <c>UseSqlServer</c> calls the leased version of the SQL 
            Server transport does not hold a transaction open for the entire duration of the message handling. Instead it marks a
            message as being "leased" for a period of time. If the lease has expired then a worker is permitted to acquire the that
            message again and try reprocessing
            </summary>
            <param name="configurer">Static to extend</param>
            <param name="connectionString">Connection string</param>
            <param name="inputQueueName">Name of the queue, which must be a valid table table in SQL Server</param>
            <param name="leaseInterval">If <c>null</c> will default to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTime"/>. Specifies how long a worker will request to keep a message. Higher values require less database communication but increase latency of a message being processed if a worker dies</param>
            <param name="leaseTolerance">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTolerance"/>. Workers will wait for this amount of time to elapse, beyond the lease time, before they pick up an already leased message.</param>
            <param name="automaticallyRenewLeases">If <c>true</c> then workers will automatically renew the lease they have acquired whilst they're still processing the message. This will occur in accordance with <paramref name="leaseAutoRenewInterval"/></param>
            <param name="leaseAutoRenewInterval">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseAutomaticRenewal"/>. Specifies how frequently a lease will be renewed whilst the worker is processing a message. Lower values decrease the chance of other workers processing the same message but increase DB communication. A value 50% of <paramref name="leaseInterval"/> should be appropriate</param>
            <param name="leasedByFactory">If non-<c>null</c> a factory which returns a string identifying this worker when it leases a message. If <c>null></c> the current machine name is used</param>
            <param name="enlistInAmbientTransaction">If <c>true</c> the connection will be enlisted in the ambient transaction if it exists, else it will create an SqlTransaction and enlist in it</param>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServerInLeaseMode(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.String,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Boolean,System.Nullable{System.TimeSpan},System.Func{System.String})">
            <summary>
            Configures Rebus to use SQL Server as its transport. The "queue" specified by <paramref name="inputQueueName"/> will be used when querying for messages.
            The message table will automatically be created if it does not exist.
            </summary>
            <param name="configurer">Static to extend</param>
            <param name="connectionFactory">Factory to provide a new connection</param>
            <param name="inputQueueName">Name of the queue, which must be a valid table table in SQL Server</param>
            <param name="leaseInterval">If <c>null</c> will default to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTime"/>. Specifies how long a worker will request to keep a message. Higher values require less database communication but increase latency of a message being processed if a worker dies</param>
            <param name="leaseTolerance">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTolerance"/>. Workers will wait for this amount of time to elapse, beyond the lease time, before they pick up an already leased message.</param>
            <param name="automaticallyRenewLeases">If <c>true</c> then workers will automatically renew the lease they have acquired whilst they're still processing the message. This will occur in accordance with <paramref name="leaseAutoRenewInterval"/></param>
            <param name="leaseAutoRenewInterval">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseAutomaticRenewal"/>. Specifies how frequently a lease will be renewed whilst the worker is processing a message. Lower values decrease the chance of other workers processing the same message but increase DB communication. A value 50% of <paramref name="leaseInterval"/> should be appropriate</param>
            <param name="leasedByFactory">If non-<c>null</c> a factory which returns a string identifying this worker when it leases a message. If <c>null></c> the current machine name is used</param>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.ConfigureInLeaseMode(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.Func{Rebus.Logging.IRebusLoggerFactory,Rebus.SqlServer.IDbConnectionProvider},System.String,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Boolean,System.Nullable{System.TimeSpan},System.Func{System.String})">
            <summary>
            Configures everything for a leased <seealso cref="T:Rebus.SqlServer.Transport.SqlServerLeaseTransport"/>
            </summary>	
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServerAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}})">
            <summary>
            Configures Rebus to use SQL Server to transport messages as a one-way client (i.e. will not be able to receive any messages).
            The message table will automatically be created if it does not exist.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServerAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to transport messages as a one-way client (i.e. will not be able to receive any messages).
            The message table will automatically be created if it does not exist.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServer(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.String)">
            <summary>
            Configures Rebus to use SQL Server as its transport. The "queue" specified by <paramref name="inputQueueName"/> will be used when querying for messages.
            The message table will automatically be created if it does not exist.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServer(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String,System.String,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server as its transport. The "queue" specified by <paramref name="inputQueueName"/> will be used when querying for messages.
            The message table will automatically be created if it does not exist.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.Configure(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.Func{Rebus.Logging.IRebusLoggerFactory,Rebus.SqlServer.IDbConnectionProvider},System.String)">
            <summary>
            Configures everything for a standard <seealso cref="T:Rebus.SqlServer.Transport.SqlServerTransport"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.AsyncHelpers.RunSync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes a task synchronously on the calling thread by installing a temporary synchronization context that queues continuations
             </summary>
        </member>
        <member name="T:Rebus.SqlServer.AsyncHelpers.CustomSynchronizationContext">
            <summary>
            Synchronization context that can be "pumped" in order to have it execute continuations posted back to it
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.AsyncHelpers.CustomSynchronizationContext.Run">
            <summary>
            Enqueues the function to be executed and executes all resulting continuations until it is completely done
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.DataBus.SqlServerDataBusStorage">
            <summary>
            Implementation of <see cref="T:Rebus.DataBus.IDataBusStorage"/> that uses SQL Server to store data
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DataBus.SqlServerDataBusStorage.#ctor(Rebus.SqlServer.IDbConnectionProvider,System.String,System.Boolean,Rebus.Logging.IRebusLoggerFactory,System.Int32)">
            <summary>
            Creates the data storage
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DataBus.SqlServerDataBusStorage.Initialize">
            <summary>
            Initializes the SQL Server data storage.
            Will create the data table, unless this has been explicitly turned off when configuring the data storage
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DataBus.SqlServerDataBusStorage.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the data from the given source stream under the given ID
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DataBus.SqlServerDataBusStorage.Read(System.String)">
            <summary>
            Opens the data stored under the given ID for reading
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DataBus.SqlServerDataBusStorage.ReadMetadata(System.String)">
            <summary>
            Loads the metadata stored with the given ID
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.DataBus.StreamWrapper">
            <summary>
            Wraps a stream and an action, calling the action when the stream is disposed
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.DbConnectionFactoryProvider">
            <summary>
            Implementation of <see cref="T:Rebus.SqlServer.IDbConnectionProvider"/> that ensures that MARS (multiple active result sets) is enabled on the
            given connection string (possibly by enabling it by itself)
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionFactoryProvider.#ctor(System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Uses provided SqlConnection factory as constructor for SqlConnection used. Will use <see cref="F:System.Data.IsolationLevel.ReadCommitted"/> by default on transactions,
            unless another isolation level is set with the <see cref="P:Rebus.SqlServer.DbConnectionFactoryProvider.IsolationLevel"/> property
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionFactoryProvider.GetConnection">
            <summary>
            Gets a nice ready-to-use database connection with an open transaction
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.DbConnectionFactoryProvider.IsolationLevel">
            <summary>
            Gets/sets the isolation level used for transactions
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.DbConnectionProvider">
            <summary>
            Implementation of <see cref="T:Rebus.SqlServer.IDbConnectionProvider"/> that ensures that MARS (multiple active result sets) is enabled on the
            given connection string (possibly by enabling it by itself)
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionProvider.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory,System.Boolean)">
            <summary>
            Wraps the connection string with the given name from app.config (if it is found), or interprets the given string as
            a connection string to use. Will use <see cref="F:System.Data.IsolationLevel.ReadCommitted"/> by default on transactions,
            unless another isolation level is set with the <see cref="P:Rebus.SqlServer.DbConnectionProvider.IsolationLevel"/> property
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionProvider.GetConnection">
            <summary>
            Gets a nice ready-to-use database connection with an open transaction
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.DbConnectionProvider.IsolationLevel">
            <summary>
            Gets/sets the isolation level used for transactions
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.DbConnectionWrapper">
            <summary>
            Wrapper of <see cref="T:System.Data.SqlClient.SqlConnection"/> that allows for either handling <see cref="T:System.Data.SqlClient.SqlTransaction"/> automatically, or for handling it externally
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionWrapper.#ctor(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlTransaction,System.Boolean)">
            <summary>
            Constructs the wrapper, wrapping the given connection and transaction. It must be indicated with <paramref name="managedExternally"/> whether this wrapper
            should commit/rollback the transaction (depending on whether <see cref="M:Rebus.SqlServer.DbConnectionWrapper.Complete"/> is called before <see cref="M:Rebus.SqlServer.DbConnectionWrapper.Dispose"/>), or if the transaction
            is handled outside of the wrapper
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionWrapper.CreateCommand">
            <summary>
            Creates a ready to used <see cref="T:System.Data.SqlClient.SqlCommand"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionWrapper.GetTableNames">
            <summary>
            Gets the names of all the tables in the current database for the current schema
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionWrapper.GetColumns(System.String,System.String)">
            <summary>
            Gets information about the columns in the table given by <paramref name="dataTableName"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionWrapper.Complete">
            <summary>
            Marks that all work has been successfully done and the <see cref="T:System.Data.SqlClient.SqlConnection"/> may have its transaction committed or whatever is natural to do at this time
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionWrapper.Dispose">
            <summary>
            Finishes the transaction and disposes the connection in order to return it to the connection pool. If the transaction
            has not been committed (by calling <see cref="M:Rebus.SqlServer.DbConnectionWrapper.Complete"/>), the transaction will be rolled back.
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.IDbConnection">
            <summary>
            Wrapper of <see cref="T:System.Data.SqlClient.SqlConnection"/> that allows for easily changing how transactions are handled, and possibly how <see cref="T:System.Data.SqlClient.SqlConnection"/> instances
            are reused by various services
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.IDbConnection.CreateCommand">
            <summary>
            Creates a ready to used <see cref="T:System.Data.SqlClient.SqlCommand"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.IDbConnection.GetTableNames">
            <summary>
            Gets the names of all the tables in the current database for the current schema
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.IDbConnection.Complete">
            <summary>
            Marks that all work has been successfully done and the <see cref="T:System.Data.SqlClient.SqlConnection"/> may have its transaction committed or whatever is natural to do at this time
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.IDbConnection.GetColumns(System.String,System.String)">
            <summary>
            Gets information about the columns in the table given by [<paramref name="schema"/>].[<paramref name="dataTableName"/>]
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.DbColumn">
            <summary>
            Represents a SQL Server column
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.DbColumn.Name">
            <summary>
            Gets the name of the column
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.DbColumn.Type">
            <summary>
            Gets the SQL datatype of the column
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbColumn.#ctor(System.String,System.Data.SqlDbType)">
            <summary>
            Creates the column
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.IDbConnectionProvider">
            <summary>
            SQL Server database connection provider that allows for easily changing how the current <see cref="T:System.Data.SqlClient.SqlConnection"/> is obtained,
            possibly also changing how transactions are handled
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.IDbConnectionProvider.GetConnection">
            <summary>
            Gets a wrapper with the current <see cref="T:System.Data.SqlClient.SqlConnection"/> inside
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Sagas.SqlServerSagaSnapshotStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Auditing.Sagas.ISagaSnapshotStorage"/> that uses a table in SQL Server to store saga snapshots
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaSnapshotStorage.#ctor(Rebus.SqlServer.IDbConnectionProvider,System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the snapshot storage
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaSnapshotStorage.EnsureTableIsCreated">
            <summary>
            Creates the subscriptions table if necessary
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaSnapshotStorage.Save(Rebus.Sagas.ISagaData,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves a snapshot of the saga data along with the given metadata
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Sagas.SqlServerSagaStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> that persists saga data as a Newtonsoft JSON.NET-serialized object to a table in SQL Server.
            Correlation properties are stored in a separate index table, allowing for looking up saga data instanes based on the configured correlation
            properties
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaStorage.#ctor(Rebus.SqlServer.IDbConnectionProvider,System.String,System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the saga storage, using the specified connection provider and tables for persistence.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaStorage.Initialize">
            <summary>
            Initializes the storage by performing a check on the schema to see whether we should use
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaStorage.EnsureTablesAreCreated">
            <summary>
            Checks to see if the configured tables exist, creating them if necessary
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaStorage.Find(System.Type,System.String,System.Object)">
            <summary>
            Queries the saga index for an instance with the given <paramref name="sagaDataType"/> with a
            a property named <paramref name="propertyName"/> and the value <paramref name="propertyValue"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaStorage.Insert(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Serializes the given <see cref="T:Rebus.Sagas.ISagaData"/> and generates entries in the index for the specified <paramref name="correlationProperties"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaStorage.Update(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Updates the given <see cref="T:Rebus.Sagas.ISagaData"/> and generates entries in the index for the specified <paramref name="correlationProperties"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaStorage.Delete(Rebus.Sagas.ISagaData)">
            <summary>
            Deletes the given <see cref="T:Rebus.Sagas.ISagaData"/> and removes all its entries in the index
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.SqlServerMagic">
            <summary>
            Wraps some nice extension methods for <see cref="T:System.Data.SqlClient.SqlConnection"/> that makes it easy e.g. to query the schema
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.SqlServerMagic.PrimaryKeyViolationNumber">
            <summary>
            Error code that is emitted on PK violations
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.SqlServerMagic.ObjectDoesNotExistOrNoPermission">
            <summary>
            Error code that is emitted when something does not exist or the login's permissions do not allow the client to see it
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.SqlServerMagic.GetTableNames(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlTransaction)">
            <summary>
            Gets the names of all tables in the current database
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.SqlServerMagic.GetIndexNames(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlTransaction)">
            <summary>
            Gets the names of all indexes in the current database
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.SqlServerMagic.GetColumns(System.Data.SqlClient.SqlConnection,System.String,System.String,System.Data.SqlClient.SqlTransaction)">
            <summary>
            Gets the names of all tables in the current database
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.SqlServerMagic.GetDatabaseNames(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlTransaction)">
            <summary>
            Gets the names of all databases on the current server
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> that persists subscriptions in a table in SQL Server
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage.#ctor(Rebus.SqlServer.IDbConnectionProvider,System.String,System.Boolean,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the storage using the specified connection provider and table to store its subscriptions. If the subscription
            storage is shared by all subscribers and publishers, the <paramref name="isCentralized"/> parameter can be set to true
            in order to subscribe/unsubscribe directly instead of sending subscription/unsubscription requests
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage.Initialize">
            <summary>
            Initializes the subscription storage by reading the lengths of the [topic] and [address] columns from SQL Server
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage.EnsureTableIsCreated">
            <summary>
            Creates the subscriptions table if necessary
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all destination addresses for the given topic
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Registers the given <paramref name="subscriberAddress"/> as a subscriber of the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Unregisters the given <paramref name="subscriberAddress"/> as a subscriber of the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage.IsCentralized">
            <summary>
            Gets whether this subscription storage is centralized
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.TableName">
            <summary>
            Represents a (possibly schema-qualified) table name in SQL Server
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.TableName.Schema">
            <summary>
            Gets the schema name of the table
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.TableName.Name">
            <summary>
            Gets the table's name
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.TableName.#ctor(System.String,System.String)">
            <summary>
            Creates a <see cref="T:Rebus.SqlServer.TableName"/> object with the given schema and table names
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.TableName.Parse(System.String)">
            <summary>
            Parses the given name into a <see cref="T:Rebus.SqlServer.TableName"/>, defaulting to using the 'dbo' schema unless the name is schema-qualified.
            E.g. 'table' will result in a <see cref="T:Rebus.SqlServer.TableName"/> representing the '[dbo].[table]' table, whereas 'accounting.messages' will
            represent the '[accounting].[messages]' table.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.TableName.ToString">
            <inheritdoc />
        </member>
        <member name="M:Rebus.SqlServer.TableName.Equals(Rebus.SqlServer.TableName)">
            <inheritdoc />
        </member>
        <member name="M:Rebus.SqlServer.TableName.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Rebus.SqlServer.TableName.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Rebus.SqlServer.TableName.op_Equality(Rebus.SqlServer.TableName,Rebus.SqlServer.TableName)">
            <summary>
            Checks whether the two <see cref="T:Rebus.SqlServer.TableName"/> objects are equal (i.e. represent the same table)
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.TableName.op_Inequality(Rebus.SqlServer.TableName,Rebus.SqlServer.TableName)">
            <summary>
            Checks whether the two <see cref="T:Rebus.SqlServer.TableName"/> objects are not equal (i.e. do not represent the same table)
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Timeouts.SqlServerTimeoutManager">
            <summary>
            Implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> that uses SQL Server to store messages until it's time to deliver them.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Timeouts.SqlServerTimeoutManager.#ctor(Rebus.SqlServer.IDbConnectionProvider,System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the timeout manager, using the specified connection provider and table to store the messages until they're due.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Timeouts.SqlServerTimeoutManager.EnsureTableIsCreated">
            <summary>
            Creates the due messages table if necessary
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Timeouts.SqlServerTimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Defers the message to the time specified by <paramref name="approximateDueTime"/> at which point in time the message will be
            returned to whoever calls <see cref="M:Rebus.SqlServer.Timeouts.SqlServerTimeoutManager.GetDueMessages"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Timeouts.SqlServerTimeoutManager.GetDueMessages">
            <summary>
            Gets messages due for delivery at the current time
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Transport.SqlServerLeaseTransport">
            <summary>
            Similar to <seealso cref="T:Rebus.SqlServer.Transport.SqlServerTransport"/> but does not maintain an active connection during message processing. Instead a "lease" is acquired for each message and only once "committed" is the message removed from the queue.
            <remarks>Note: This also changes the semantics of sending. Sent messages are queued in memory and are not committed to memory until the sender has committed</remarks>
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.OutboundMessageBufferKey">
            <summary>
            Key for storing the outbound message buffer when performing <seealso cref="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)"/>
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.LeasedByColumnSize">
            <summary>
            Size of the leasedby column
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTime">
            <summary>
            If not specified the default time messages are leased for
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTolerance">
            <summary>
            If not specified the amount of tolerance workers will allow a message which has already been leased
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseAutomaticRenewal">
            <summary>
            If not specified the amount of time the workers will automatically renew leases for actively handled messages
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.#ctor(Rebus.SqlServer.IDbConnectionProvider,System.String,Rebus.Logging.IRebusLoggerFactory,Rebus.Threading.IAsyncTaskFactory,System.TimeSpan,System.Nullable{System.TimeSpan},System.Func{System.String},System.Nullable{System.TimeSpan})">
            <summary>
            Constructor
            </summary>
            <param name="connectionProvider">A <see cref="T:Rebus.SqlServer.IDbConnection"/> to obtain a database connection</param>
            <param name="inputQueueName">Name of the queue this transport is servicing</param>
            <param name="rebusLoggerFactory">A <seealso cref="T:Rebus.Logging.IRebusLoggerFactory"/> for building loggers</param>
            <param name="asyncTaskFactory">A <seealso cref="T:Rebus.Threading.IAsyncTaskFactory"/> for creating periodic tasks</param>
            <param name="leaseInterval">Interval of time messages are leased for</param>
            <param name="leaseTolerance">Buffer to allow lease overruns by</param>
            <param name="leasedByFactory">Factory for generating a string which identifies who has leased a message (eg. A hostname)</param>
            <param name="automaticLeaseRenewalInterval">If non-<c>null</c> messages will be automatically re-leased after this time period has elapsed</param>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Sends the given transport message to the specified logical destination address by adding it to the messages table.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.ReceiveInternal(Rebus.Transport.ITransactionContext,System.Threading.CancellationToken)">
            <summary>
            Handle retrieving a message from the queue, decoding it, and performing any transaction maintenance.
            </summary>
            <param name="context">Tranasction context the receive is operating on</param>
            <param name="cancellationToken">Token to abort processing</param>
            <returns>A <seealso cref="T:Rebus.Messages.TransportMessage"/> or <c>null</c> if no message can be dequeued</returns>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.AdditionalSchemaModifications">
            <summary>
            Provides an oppurtunity for derived implementations to also update the schema
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.ApplyTransactionSemantics(Rebus.Transport.ITransactionContext,System.Int64)">
            <summary>
            Responsible for releasing the lease on message failure and removing the message on transaction commit
            </summary>
            <param name="context">Transaction context of the message processing</param>
            <param name="messageId">Identifier of the message currently being processed</param>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.GetOutboundMessageBuffer(Rebus.Transport.ITransactionContext)">
            <summary>
            Gets the outbound message buffer for sending of messages
            </summary>
            <param name="context">Transaction context containing the message bufffer</param>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.UpdateLease(Rebus.SqlServer.IDbConnectionProvider,System.String,System.Int64,System.Nullable{System.Int64})">
            <summary>
            Updates a lease with a new leaseduntil value
            </summary>
            <param name="connectionProvider">Provider for obtaining a connection</param>
            <param name="tableName">Name of the table the messages are stored in</param>
            <param name="messageId">Identifier of the message whose lease is being updated</param>
            <param name="leaseIntervalMilliseconds">New lease interval in milliseconds. If <c>null</c> the lease will be released</param>
        </member>
        <member name="T:Rebus.SqlServer.Transport.SqlServerLeaseTransport.AutomaticLeaseRenewer">
            <summary>
            Handles automatically renewing a lease for a given message
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Transport.SqlServerTransport">
            <summary>
            Implementation of <see cref="T:Rebus.Transport.ITransport"/> that uses SQL Server to do its thing
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerTransport.MagicExternalTimeoutManagerAddress">
            <summary>
            When a message is sent to this address, it will be deferred into the future!
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerTransport.MessagePriorityHeaderKey">
            <summary>
            Special message priority header that can be used with the <see cref="T:Rebus.SqlServer.Transport.SqlServerTransport"/>. The value must be an <see cref="T:System.Int32"/>
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerTransport.CurrentConnectionKey">
            <summary>
            Key of the transport's currently used database connection. Can be retrieved from the context and used e.g.
            in a connection provider which is then in turn used in repositories and such. This way, "exactly once delivery" can actually be had.
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerTransport.DefaultExpiredMessagesCleanupInterval">
            <summary>
            Default interval that will be used for <see cref="P:Rebus.SqlServer.Transport.SqlServerTransport.ExpiredMessagesCleanupInterval"/> unless it is explicitly set to something else
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerTransport.RecipientColumnSize">
            <summary>
            Size, in the database, of the recipient column
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerTransport.ConnectionProvider">
            <summary>
            Connection provider for obtaining a database connection
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerTransport.ReceiveTableName">
            <summary>
            Name of the table this transport is using for storage
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.#ctor(Rebus.SqlServer.IDbConnectionProvider,System.String,Rebus.Logging.IRebusLoggerFactory,Rebus.Threading.IAsyncTaskFactory)">
            <summary>
            Constructs the transport with the given <see cref="T:Rebus.SqlServer.IDbConnectionProvider"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.Initialize">
            <summary>
            Initializes the transport by starting a task that deletes expired messages from the SQL table
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.Transport.SqlServerTransport.ExpiredMessagesCleanupInterval">
            <summary>
            Configures the interval between periodic deletion of expired messages. Defaults to <see cref="F:Rebus.SqlServer.Transport.SqlServerTransport.DefaultExpiredMessagesCleanupInterval"/>
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.Transport.SqlServerTransport.Address">
            <summary>
            Gets the name that this SQL transport will use to query by when checking the messages table
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.CreateQueue(System.String)">
            <summary>
            Creates the table named after the given <paramref name="address"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.EnsureTableIsCreated">
            <summary>
            Checks if the table with the configured name exists - if not, it will be created
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.AdditionalSchemaModifications">
            <summary>
            Provides an oppurtunity for derived implementations to also update the schema
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Sends the given transport message to the specified destination queue address by adding it to the queue's table.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.Receive(Rebus.Transport.ITransactionContext,System.Threading.CancellationToken)">
            <summary>
            Receives the next message by querying the input queue table for a message with a recipient matching this transport's <see cref="P:Rebus.SqlServer.Transport.SqlServerTransport.Address"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.ReceiveInternal(Rebus.Transport.ITransactionContext,System.Threading.CancellationToken)">
            <summary>
            Handle retrieving a message from the queue, decoding it, and performing any transaction maintenance.
            </summary>
            <param name="context">Tranasction context the receive is operating on</param>
            <param name="cancellationToken">Token to abort processing</param>
            <returns>A <seealso cref="T:Rebus.Messages.TransportMessage"/> or <c>null</c> if no message can be dequeued</returns>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.ExtractTransportMessageFromReader(System.Data.SqlClient.SqlDataReader,System.Threading.CancellationToken)">
            <summary>
            Maps a <seealso cref="T:System.Data.SqlClient.SqlDataReader"/> that's read a result from the message table into a <seealso cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
            <returns>A <seealso cref="T:Rebus.Messages.TransportMessage"/> representing the row or <c>null</c> if no row was available</returns>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.GetDestinationAddressToUse(System.String,Rebus.Messages.TransportMessage)">
            <summary>
            Gets the address a message will actually be sent to. Handles deferred messsages.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.InnerSend(System.String,Rebus.Messages.TransportMessage,Rebus.SqlServer.IDbConnection)">
            <summary>
            Performs persistence of a message to the underlying table
            </summary>
            <param name="destinationAddress">Address the message will be sent to</param>
            <param name="message">Message to be sent</param>
            <param name="connection">Connection to use for writing to the database</param>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.Dispose">
            <summary>
            Shuts down the background timer
            </summary>
        </member>
    </members>
</doc>
