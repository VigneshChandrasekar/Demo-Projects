<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Rebus</name>
    </assembly>
    <members>
        <member name="T:Rebus.Activation.BuiltinHandlerActivator">
            <summary>
            Built-in handler activator that can be used when dependency injection is not required, or when inline
            lambda-based handlers are wanted
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Returns all relevant handler instances for the given message by looking up compatible registered functions and instance factory methods.
            </summary>
        </member>
        <member name="P:Rebus.Activation.BuiltinHandlerActivator.Bus">
            <summary>
            Gets the bus instance that this activator was configured with
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.SetBus(Rebus.Bus.IBus)">
            <summary>
            Stores the bus instance
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{Rebus.Bus.IBus,Rebus.Pipeline.IMessageContext,``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/> with the <see cref="T:Rebus.Bus.IBus"/> and the current <see cref="T:Rebus.Pipeline.IMessageContext"/> available
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{Rebus.Bus.IBus,``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/> with the <see cref="T:Rebus.Bus.IBus"/> available
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{Rebus.Pipeline.IMessageContext,``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{Rebus.Bus.IBus,Rebus.Pipeline.IMessageContext,``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Dispose">
            <summary>
            Disposes the contained bus instance
            </summary>
        </member>
        <member name="T:Rebus.Activation.IContainerAdapter">
            <summary>
            Extends <see cref="T:Rebus.Activation.IHandlerActivator"/> with the expectation that it is backed by some kind of IoC container that can hold
            a bus instance (which it naturally should be able to inject into handlers when they're activated)
            </summary>
        </member>
        <member name="M:Rebus.Activation.IContainerAdapter.SetBus(Rebus.Bus.IBus)">
            <summary>
            Sets the bus instance that this <see cref="T:Rebus.Activation.IContainerAdapter"/> should be able to inject when resolving handler instances
            </summary>
        </member>
        <member name="T:Rebus.Activation.IHandlerActivator">
            <summary>
            Responsible for creating handlers for a given message type
            </summary>
        </member>
        <member name="M:Rebus.Activation.IHandlerActivator.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Must return all relevant handler instances for the given message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.AuditHeaders">
            <summary>
            Headers relevant when using message auditing
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.AuditTime">
            <summary>
            Header with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the message copy was forwarded to the audit queue.
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.HandleTime">
            <summary>
            Header with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the audited message was received.
            Only present on copies of handled messages (i.e. not on messages with <see cref="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe"/>
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.HandleQueue">
            <summary>
            Header with the queue name from which the message was received. 
            Only present on copies of handled messages (i.e. not on messages with <see cref="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe"/>
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.MachineName">
            <summary>
            Name of the machine that processed/published the message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.IncomingAuditingStep">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IIncomingStep"/> and <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that handles message auditing
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.IncomingAuditingStep.#ctor(Rebus.Auditing.Messages.AuditingHelper,Rebus.Transport.ITransport)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.MessageAuditingConfigurationExtensions">
            <summary>
            Configuration extensions for the auditing configuration
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.MessageAuditingConfigurationExtensions.EnableMessageAuditing(Rebus.Config.OptionsConfigurer,System.String)">
            <summary>
            Enables message auditing whereby Rebus will forward to the audit queue a copy of each properly handled message and
            each published message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.OutgoingAuditingStep">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IIncomingStep"/> and <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that handles message auditing
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.OutgoingAuditingStep.#ctor(Rebus.Auditing.Messages.AuditingHelper,Rebus.Transport.ITransport)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.ISagaSnapshotStorage">
            <summary>
            Saga snapshot storage that archives a snapshot of the given saga data
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.ISagaSnapshotStorage.Save(Rebus.Sagas.ISagaData,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Archives the given saga data under its current ID and revision
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions">
            <summary>
            Configuration extensions for the auditing configuration
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions.EnableSagaAuditing(Rebus.Config.OptionsConfigurer)">
            <summary>
            Enables saga auditing which will cause Rebus to save a snapshot of each saga state to the configured snapshot storage.
            Please remember to select a saga snapshot storage by calling an extension on the returned <see cref="T:Rebus.Config.StandardConfigurer`1"/>, e.g. like so:
            <code>
            Configure.With(..)
                .(...)
                .Options(o => o.EnableSagaAuditing().StoreInSqlServer(....))
                .Start();
            </code>
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions.OutputToLog(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage})">
            <summary>
            Configures Rebus to output saga snapshots to the log. Each saga data mutation will be logged as a serialized JSON object without type information
            with INFO level to the class-logger of <see cref="T:Rebus.Auditing.Sagas.LoggerSagaSnapperShotter"/>.
            This is probably mostly useful in debugging scenarios, or as a simple auditing mechanism in cases where sagas don't expect a lot of traffic.
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys">
            <summary>
            Contains keys of metadata elements that can be found alongside saga data snapshots when saga auditing has been enabled
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.HandleQueue">
            <summary>
            Key of the input queue address of the endpoint that handled the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.SagaDataType">
            <summary>
            Key of the type of the saga data
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.SagaHandlerType">
            <summary>
            Key of the type of the saga handler that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MessageType">
            <summary>
            Key of the type of the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MessageId">
            <summary>
            Key of the ID of the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MachineName">
            <summary>
            Key of the machine name on which the saga data was brought to the current state
            </summary>
        </member>
        <member name="T:Rebus.Backoff.BackoffConfigurationExtensions">
            <summary>
            Configuration extensions for customizing the backoff behavior
            </summary>
        </member>
        <member name="M:Rebus.Backoff.BackoffConfigurationExtensions.SetBackoffTimes(Rebus.Config.OptionsConfigurer,System.TimeSpan[])">
            <summary>
            Configures the timespans to wait when backing off polling the transport during idle times. <paramref name="backoffTimes"/>
            must be a sequence of timespans, which indicates the time to wait for each second elapsed being idle. When the idle time
            exceeds the number of timespans, the last timespan will be used.
            </summary>
        </member>
        <member name="M:Rebus.Backoff.BackoffConfigurationExtensions.SetBackoffTimes(Rebus.Config.OptionsConfigurer,System.Collections.Generic.IEnumerable{System.TimeSpan})">
            <summary>
            Configures the timespans to wait when backing off polling the transport during idle times. <paramref name="backoffTimes"/>
            must be a sequence of timespans, which indicates the time to wait for each second elapsed being idle. When the idle time
            exceeds the number of timespans, the last timespan will be used.
            </summary>
        </member>
        <member name="T:Rebus.Bus.RebusBus">
            <summary>
            The implementations of the advanced APIs are private classes inside <see cref="T:Rebus.Bus.RebusBus"/> so that they can access private functions and stuff
            </summary>
            <summary>
            This is the main bus thing which you'll most likely hold on to
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.#ctor(Rebus.Workers.IWorkerFactory,Rebus.Routing.IRouter,Rebus.Transport.ITransport,Rebus.Pipeline.IPipelineInvoker,Rebus.Subscriptions.ISubscriptionStorage,Rebus.Config.Options,Rebus.Logging.IRebusLoggerFactory,Rebus.Bus.BusLifetimeEvents,Rebus.DataBus.IDataBus,Rebus.Topic.ITopicNameConvention)">
            <summary>
            Constructs the bus.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Start(System.Int32)">
            <summary>
            Starts the bus by adding the specified number of workers
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to this instance's own input queue, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to the address mapped as the owner of the message type, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.DeferLocal(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the bus instance's own input address will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the endpoint mapping corresponding to the sent message will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Replies back to the endpoint specified as return address on the message currently being handled. Throws an <see cref="T:System.InvalidOperationException"/> if
            called outside of a proper message context.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Subscribe(System.Type)">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <paramref name="eventType"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Unsubscribe(System.Type)">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <paramref name="eventType"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="P:Rebus.Bus.RebusBus.Advanced">
            <summary>
            Gets the API for advanced features of the bus
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerPublish(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the specified event message on the specified topic, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerSubscribe(System.String)">
            <summary>
            Subscribes to the specified topic. If the current subscription storage is centralized, the subscription will be established right away. Otherwise, a <see cref="T:Rebus.Messages.Control.SubscribeRequest"/>
            will be sent to the address mapped as the owner (i.e. the publisher) of the given topic.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerUnsubscribe(System.String)">
            <summary>
            Unsubscribes from the specified topic. If the current subscription storage is centralized, the subscription will be removed right away. Otherwise, an <see cref="T:Rebus.Messages.Control.UnsubscribeRequest"/>
            will be sent to the address mapped as the owner (i.e. the publisher) of the given topic.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Dispose">
            <summary>
            Stops all workers, allowing them to finish handling the current message (for up to 1 minute) before exiting
            </summary>
        </member>
        <member name="E:Rebus.Bus.RebusBus.Disposed">
            <summary>
            Event that is raised when the bus is disposed
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.SetNumberOfWorkers(System.Int32)">
            <summary>
            Sets the number of workers by adding/removing one worker at a time until
            the desired number is reached
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.ToString">
            <summary>
            Gets a label for this bus instance - e.g. "RebusBus 2" if this is the 2nd instance created, ever, in the current process
            (or the name used when configuring it, if the name has been customized)
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.AsyncHelpers.RunSync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes a task synchronously on the calling thread by installing a temporary synchronization context that queues continuations
             </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.AsyncHelpers.CustomSynchronizationContext">
            <summary>
            Synchronization context that can be "pumped" in order to have it execute continuations posted back to it
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.AsyncHelpers.CustomSynchronizationContext.Run">
            <summary>
            Enqueues the function to be executed and executes all resulting continuations until it is completely done
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IAdvancedApi">
            <summary>
            API for the advanced features of the bus
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Workers">
            <summary>
            Gets an API to query/control various aspects around Rebus' workers
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Topics">
            <summary>
            Gets an API to do pub/sub on raw string-based topics
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Routing">
            <summary>
            Gets an API to explicitly route messages
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.TransportMessage">
            <summary>
            Gets an API to perform operations with the transport message currently being handled
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.DataBus">
            <summary>
            Gets the API for the data bus
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.SyncBus">
            <summary>
            Exposes a synchronous version of <see cref="T:Rebus.Bus.IBus"/> that essentially mimics all APIs only providing them in a synchronous version
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IRoutingApi">
            <summary>
            Provides a raw API for explicitly routing messages to other endpoints
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IRoutingApi.Send(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Explicitly routes the <paramref name="explicitlyRoutedMessage"/> to the destination specified by <paramref name="destinationAddress"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IRoutingApi.SendRoutingSlip(Rebus.Routing.Itinerary,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the message as a routing slip that will visit the destinations specified by the given <see cref="T:Rebus.Routing.Itinerary"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IRoutingApi.Defer(System.String,System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Explicitly routes the <paramref name="explicitlyRoutedMessage"/> to the destination specified by <paramref name="destinationAddress"/>,
            delaying delivery approximately by the time specified by <paramref name="delay"/>.
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ISyncBus">
            <summary>
            Synchronous API for all of the async-native operations of the Rebus <see cref="T:Rebus.Bus.IBus"/>. May be used in applications 
            that need to perform bus operations deep within a call hierarchy, or that simply do not contain an appropriate place
            to await something. Safe to use in applications that insist on running continuations on the initiating thread, like 
            e.g. ASP.NET and WPF.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified message to our own input queue address
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified message to a destination that is determined by calling <see cref="M:Rebus.Routing.IRouter.GetDestinationAddress(Rebus.Messages.Message)"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified reply message to a destination that is determined by looking up the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header of the message currently being handled.
            This method can only be called from within a message handler.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the endpoint mapping corresponding to the sent message will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.DeferLocal(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the bus instance's own input address will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Subscribe(System.Type)">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <paramref name="eventType"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Unsubscribe(System.Type)">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <paramref name="eventType"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ITopicsApi">
            <summary>
            Provides the raw topic-based pub/sub API which is used underneath the type-based pub/sub api provided by <see cref="T:Rebus.Bus.IBus"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Publish(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the specified message to the specified topic. Default behavior is to look up the addresses of those who subscribed to the given topic
            by calling <see cref="M:Rebus.Subscriptions.ISubscriptionStorage.GetSubscriberAddresses(System.String)"/> but the transport may override this behavior if it has special capabilities.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Subscribe(System.String)">
            <summary>
            Subscribes the current endpoint to the given topic. If the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> is centralized (determined by checking <see cref="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized"/>),
            the subscription is registered immediately. If not, the owner of the given topic is checked (by calling <see cref="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)"/>), and a
            <see cref="T:Rebus.Messages.Control.SubscribeRequest"/> is sent to the owning endpoint).
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Unsubscribe(System.String)">
            <summary>
            Unsubscribes the current endpoint from the given topic. If the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> is centralized (determined by checking <see cref="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized"/>),
            the subscription is removed immediately. If not, the owner of the given topic is checked (by calling <see cref="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)"/>), and an
            <see cref="T:Rebus.Messages.Control.UnsubscribeRequest"/> is sent to the owning endpoint).
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ITransportMessageApi">
            <summary>
            Contains operations that can be performed on the transport message currently being handled
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITransportMessageApi.Forward(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Forwards the transport message currently being handled to the specified queue, optionally supplying some extra headers
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITransportMessageApi.Defer(System.TimeSpan,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers the transport message currently being handled some time into the future, optionally specifying some additional headers
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IWorkersApi">
            <summary>
            Defines an API for working with workers
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IWorkersApi.Count">
            <summary>
            Gets how many workers are currently running
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IWorkersApi.SetNumberOfWorkers(System.Int32)">
            <summary>
            Sets the number of workers, blocking until the desired number has been reached
            </summary>
        </member>
        <member name="T:Rebus.Bus.BusLifetimeEvents">
            <summary>
            Has events that can be subscribed to if one wants to be notified when certain things happen
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusStarting">
            <summary>
            Event that is raised when the bus is starting BEFORE the bus adds any workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusStarted">
            <summary>
            Event that is raised when the bus is starting AFTER the bus hass added its workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusDisposing">
            <summary>
            Event that is raised when the bus is disposed BEFORE the bus raises its own <see cref="E:Rebus.Bus.RebusBus.Disposed"/> event
            BEFORE the bus stops its workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.WorkersStopped">
            <summary>
            Event that is raised when the bus is disposed BEFORE the bus raises its own <see cref="E:Rebus.Bus.RebusBus.Disposed"/> event, AFTER the bus has stopped all workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusDisposed">
            <summary>
            Event that is raised when the bus is disposed AFTER the bus raises its own <see cref="E:Rebus.Bus.RebusBus.Disposed"/> event
            </summary>
        </member>
        <member name="T:Rebus.Bus.IBus">
            <summary>
            This is the main bus API
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to this instance's own input queue, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to the address mapped as the owner of the message type, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.DeferLocal(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers the message delivery into the future, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the bus instance's own input queue address will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers the message delivery into the future, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the endpoint mapping corresponding to the sent message will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Replies back to the endpoint specified as return address on the message currently being handled. Throws an <see cref="T:System.InvalidOperationException"/> if called outside of a proper message context.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Subscribe(System.Type)">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <paramref name="eventType"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Unsubscribe(System.Type)">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <paramref name="eventType"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="P:Rebus.Bus.IBus.Advanced">
            <summary>
            Gets the API for advanced features of the bus
            </summary>
        </member>
        <member name="T:Rebus.Bus.IInitializable">
            <summary>
            Anything that is resolved with the injectionist can be marked as initializable by implementing this interface, which
            will then have its <see cref="M:Rebus.Bus.IInitializable.Initialize"/> method called before the bus is started
            </summary>
        </member>
        <member name="M:Rebus.Bus.IInitializable.Initialize">
            <summary>
            Initializes the instance
            </summary>
        </member>
        <member name="T:Rebus.Bus.MessageExtensions">
            <summary>
            Small helpers that make it easier to work with the <see cref="T:Rebus.Messages.Message"/> class
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.HasReturnAddress(Rebus.Messages.Message)">
            <summary>
            Gets whether the message's <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header is set to something
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetReturnAddressFromTransport(Rebus.Messages.Message,Rebus.Transport.ITransport)">
            <summary>
            Uses the transport's input queue address as the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> on the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetDeferHeaders(Rebus.Messages.Message,System.DateTimeOffset,System.String)">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header to the specified time
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetDeferHeaders(Rebus.Messages.TransportMessage,System.DateTimeOffset,System.String)">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header to the specified time
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageType(Rebus.Messages.Message)">
            <summary>
            Gets the message type from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageType(Rebus.Messages.TransportMessage)">
            <summary>
            Gets the message type from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageId(Rebus.Messages.Message)">
            <summary>
            Gets the message ID from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageId(Rebus.Messages.TransportMessage)">
            <summary>
            Gets the message ID from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageLabel(Rebus.Messages.Message)">
            <summary>
            Gets a nice label for the message, consisting of message type and ID if possible
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageLabel(Rebus.Messages.TransportMessage)">
            <summary>
            Gets a nice label for the message, consisting of message type and ID if possible
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.Clone(Rebus.Messages.TransportMessage)">
            <summary>
            Returns a cloned instance of the transport message
            </summary>
        </member>
        <member name="T:Rebus.Compression.DataCompressionMode">
            <summary>
            Enumerates strategies for when the data bus storage decorator GZIps the data
            </summary>
        </member>
        <member name="F:Rebus.Compression.DataCompressionMode.Always">
            <summary>
            Always compresses data. Please note that this requires that data can be kept in memory as this
            is required by the streaming APIs used when compressing data
            </summary>
        </member>
        <member name="F:Rebus.Compression.DataCompressionMode.Explicit">
            <summary>
            Compresses data when the <see cref="F:Rebus.DataBus.MetadataKeys.ContentEncoding"/> key is detected among the metadata
            of the save data and the value is "gzip"
            </summary>
        </member>
        <member name="T:Rebus.Compression.ZipConfigurationExtensions">
            <summary>
            Configuration extensions for enabling compression
            </summary>
        </member>
        <member name="F:Rebus.Compression.ZipConfigurationExtensions.DefaultBodyThresholdBytes">
            <summary>
            Default threshold for the body size for compression to kick in
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZipConfigurationExtensions.EnableCompression(Rebus.Config.OptionsConfigurer,System.Int32)">
            <summary>
            Enables compression of outgoing messages if the size exceeds the specified number of bytes
            (defaults to <see cref="F:Rebus.Compression.ZipConfigurationExtensions.DefaultBodyThresholdBytes"/>)
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZipConfigurationExtensions.UseCompression(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},Rebus.Compression.DataCompressionMode)">
            <summary>
            Enables GZIP of the saved data bus data. Set <paramref name="dataCompressionMode"/> to control when data is gzipped - if <see cref="F:Rebus.Compression.DataCompressionMode.Always"/>
            is selected the data will always be GZIPped, whereas selecting <see cref="F:Rebus.Compression.DataCompressionMode.Explicit"/> makes the data be GZIPped
            only when <see cref="F:Rebus.DataBus.MetadataKeys.ContentEncoding"/> = "gzip" is detected among the metadata for the stored data.
            Please note that GZIPping the data requires that it can be fully contained in memory because the underlying streaming APIs do not support lazy-reading a
            GZIP stream.
            </summary>
        </member>
        <member name="T:Rebus.Compression.Zipper">
            <summary>
            Zipper that holds the zipping logic
            </summary>
        </member>
        <member name="M:Rebus.Compression.Zipper.Zip(System.Byte[])">
            <summary>
            Zips the byte array
            </summary>
        </member>
        <member name="M:Rebus.Compression.Zipper.Unzip(System.Byte[])">
            <summary>
            Unzips the byte array
            </summary>
        </member>
        <member name="T:Rebus.Compression.ZippingDataBusStorageDecorator">
            <summary>
            Decorat